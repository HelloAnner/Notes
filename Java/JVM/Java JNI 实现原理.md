#### 前言
cpu 只认得 “0101101” 类似这种符号， C、C++ 这些代码最终都得通过编译、汇编成[二进制](https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020)代码，cpu 才能识别。而 Java 比 C、C++ 又多了一层虚拟机，过程也复杂许多。Java 代码经过编译成 class 文件、虚拟机装载等步骤最终在虚拟机中执行。class 文件里面就是一个结构复杂的表，而最终告诉虚拟机怎么执行的就靠里面的字节码说明。

Java [虚拟机](https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020)在执行的时候，可以采用解释执行和编译执行的方式执行，但最终都是转化为机器码执行。

==Java 虚拟机运行时的数据区，包括方法区、虚拟机栈、堆、程序计数器、本地方法栈==。

问题来了，按我目前的理解，如果是解释执行，那么方法区中应该存的是[字节码](https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020)，那执行的时候，通过 JNI 动态装载的 c、c++ 库，放哪去？怎么执行?

#### JNI 的简单实现
