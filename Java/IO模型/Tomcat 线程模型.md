
### 概括性说明IO类型

- **磁盘I/O**：现代电脑中都有一个DMA(Direct Memory Access 直接内存访问) 的外设组件，可以将I/O数据直接传送到主存储器中并且传输不需要CPU的参与，以此将CPU解放出来去完成其他的事情。
- **网络I/O**：NIO、AIO等I/O模型，通过向事件选择器注册I/O事件，基于就绪的事情来驱动执行I/O操作，避免的等待过程。
- **内存I/O**：内存部分没涉及到太多阻塞，优化点在于减少用户态和内核态之间的数据拷贝。nio中的零拷贝就有mmap和sendfile等实现方案

### Reactor模式

Reactor模式称之为响应器模式，通常用于`NIO`非阻塞IO的网络通信框架中。Reactor设计模式用于处理由一个或多个客户端并发传递给应用程序的的服务请求，可以理解成，`Reactor模式是用来实现网络NIO的方式`

Reactor是一种事件驱动机制，是处理并发I/O常见的一种模式，用于同步I/O，其中心思想是将所有要处理的I/O事件注册到一个中心I/O多路复用器上，同时主线程阻塞在多路复用器上，一旦有I/O事件到来或是准备就绪，多路复用器将返回并将相应I/O事件分发到对应的处理器中

Reactor模式主要分为下面三个部分：

1. **事件接收器Acceptor**：主要负责接收请求连接，接收请求后，会将建立的连接注册到分离器中。
2. **事件分离器Reactor**：依赖于循环监听多路复用器Selector，是阻塞的，一旦监听到事件，就会将事件分发到事件处理器。（例如：监听读事件，等到内核态数据就绪后，将事件分发到Handler，Handler将数据读到用户态再做处理）
3. **事件处理器Handler**：事件处理器主要完成相关的事件处理，比如读写I/O操作。

#### 三种Reactor模式

##### 单线程Reactor模式

建立连接（Acceptor）、监听accept、read、write事件（Reactor）、处理事件（Handler）都只用一个单线程

##### 多线程Reactor模式

一个线程 + 一个线程池：

- 单线程：建立连接（Acceptor）和 监听accept、read、write事件（Reactor），复用一个线程。
- 工作线程池：处理事件（Handler），由一个工作线程池来执行业务逻辑，包括数据就绪后，用户态的数据读写。

==##### 主从Reactor模式==

三个线程池：

- 主线程池：建立连接（Acceptor），并且将accept事件注册到从线程池。
- 从线程池：监听accept、read、write事件（Reactor），包括等待数据就绪时，内核态的数据I读写。
- 工作线程池：处理事件（Handler），由一个工作线程池来执行业务逻辑，包括数据就绪后，用户态的数据读写。

## Tomcat线程模型

后台处理一个请求的流程:
- **accept**：接收客户端的连接请求，创建socket连接（tcp三次握手，创建连接）。
- **read**：从socket读取数据，包括等待读就绪，和实际读数据。
- **decode**：解码，因为网络上的数据都是以byte的形式进行传输的，要想获取真正的请求，必定需要解码。
- **process**：业务处理，即服务端程序的业务逻辑实现。
- **encode**：编码，同理，因为网络上的数据都是以byte的形式进行传输的，也就是socket只接收byte，所以必定需要编码。
- **send**：往网络socket写回数据，包括实际写数据，和等待写就绪


- **BIO**：阻塞式IO，tomcat7之前默认，采用传统的java IO进行操作，该模式下每个请求都会创建一个线程，适用于并发量小的场景。
- **NIO**：同步非阻塞，比传统BIO能更好的支持大并发，tomcat 8.0 后默认采用该模式。
- **AIO**：异步非阻塞 (NIO2)，tomcat8.0后支持。多用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂。
- **APR**：tomcat 以JNI形式调用http服务器的核心动态链接库来处理文件读取或网络传输操作，需要编译安装APR库（也就是说IO操作的部分直接调用native代码实现

各个线程模型中，NIO是作为目前最实用的线程模型，因此也是目前Tomcat默认的线程模型


- BIO模型中，一个线程对应一个请求连接的完整过程，因此tomcat服务能处理的最大连接数，和最大线程数一致。
- NIO模型中，在一个请求连接中，对应的一个工作线程，只处理I/O读写就绪后的非阻塞过程。因此tomcat服务能处理的最大连接数，要远大于最大线程数量


- **最大线程数（server.tomcat.threads.max）**：工作线程池的最大线程数，默认200。注意不是越大越好，如果线程数过大，那么CPU会花费大量的时间用于线程的切换，整体效率会降低。
- **最小线程数（server.tomcat.threads.min-spare）**：工作线程池的最小线程数，默认10。
- **最大等待数（server.tomcat.accept-count）**：当调用HTTP请求数达到tomcat的最大线程数时，还有新的HTTP请求到来，这时tomcat会将该请求放在等待队列中，这个acceptCount就是指能够接受的最大等待数，默认100。如果等待队列也被放满了，这个时候再来新的请求就会被tomcat拒绝。
- **最大连接数（server.tomcat.max-connections）**：在同一时间，tomcat能够接受的最大连接数，默认8192。


- **Acceptor**：Accepter线程专门负责建立网络连接（`accept`）。新连接创建后，不是直接使用Worker线程处理请求，而是先将请求发送给Poller缓冲队列。
- **Poller**：在Poller中，维护了一个Selector对象，当Poller从缓冲队列中取出连接后，注册到该Selector中，阻塞等待读写就绪（`read等待就绪、send等待就绪`）。
- **Handlers**：遍历Selector，找出其中就绪的IO操作，并交给Worker线程处理（`read内存读、decode、process、encode、send内存写`）